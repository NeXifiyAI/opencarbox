name: ü§ñ Full Autonomy - Complete Automation System

# VOLLST√ÑNDIG AUTONOMES SYSTEM
# L√∂st automatisch: Issues, PRs, Bugs, Features, Deployment
# Keine menschliche Intervention erforderlich

on:
  issues:
    types: [opened, reopened, labeled]
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main, develop]
  schedule:
    # Alle 15 Minuten - Kontinuierliche autonome Verbesserung
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      mode:
        description: 'Autonomy Level'
        default: 'full'
        type: choice
        options:
          - full
          - aggressive
          - ultra-aggressive

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  deployments: write
  security-events: write
  statuses: write
  workflows: write
  packages: write
  pages: write

concurrency:
  group: autonomy-${{ github.event_name }}
  cancel-in-progress: false

env:
  GH_TOKEN: ${{ secrets.GH_TOKEN }}
  DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
  VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  NODE_VERSION: '20'

jobs:
  # ============================================================
  # AUTONOMOUS ISSUE RESOLVER - L√∂st automatisch ALLE Issues
  # ============================================================
  auto-solve-issues:
    name: üéØ Auto-Solve Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' || github.event_name == 'schedule'
    timeout-minutes: 20
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Setup Environment
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Autonomous Issue Processing
        uses: actions/github-script@v7
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            console.log('ü§ñ AUTONOMER MODUS: Issue-L√∂sung gestartet');
            
            // Hole alle offenen Issues
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 10,
              sort: 'created',
              direction: 'desc'
            });
            
            const openIssues = issues.filter(i => !i.pull_request);
            console.log(`üìã Gefunden: ${openIssues.length} offene Issues`);
            
            for (const issue of openIssues.slice(0, 5)) {
              console.log(`\nüîç Verarbeite Issue #${issue.number}: ${issue.title}`);
              
              // Markiere als "in Bearbeitung"
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['ü§ñ autonomous-bot', 'in-progress']
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: 'ü§ñ **Autonomes System aktiviert**\n\nIch analysiere dieses Issue und erstelle automatisch eine L√∂sung.\n\n‚è≥ Gesch√§tzte Zeit: 2-5 Minuten'
              });
              
              // AI-Analyse und L√∂sung generieren
              const prompt = `Projekt: OpenCarBox (Next.js 15, TypeScript, Supabase, Tailwind)
              
Issue #${issue.number}: ${issue.title}

Beschreibung:
${issue.body || 'Keine Beschreibung'}

AUFGABE: Erstelle eine vollst√§ndige L√∂sung f√ºr dieses Issue.

Antworte im JSON-Format:
{
  "analysis": "Detaillierte Problemanalyse",
  "solution_type": "feature|bugfix|documentation|refactor",
  "complexity": "low|medium|high",
  "files": [
    {
      "path": "src/path/to/file.ts",
      "action": "create|update|delete",
      "content": "Vollst√§ndiger Dateiinhalt"
    }
  ],
  "tests": [
    {
      "path": "tests/path/to/test.ts",
      "content": "Test-Code"
    }
  ],
  "commit_message": "feat/fix: Beschreibende Message",
  "pr_title": "PR Titel",
  "pr_body": "Detaillierte PR-Beschreibung"
}`;

              const response = await fetch('https://api.deepseek.com/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`
                },
                body: JSON.stringify({
                  model: 'deepseek-chat',
                  messages: [
                    {
                      role: 'system',
                      content: 'Du bist ein autonomer Senior-Entwickler. Erstelle vollst√§ndige, produktionsreife L√∂sungen. Antworte NUR mit dem JSON-Format, keine zus√§tzlichen Erkl√§rungen.'
                    },
                    {
                      role: 'user',
                      content: prompt
                    }
                  ],
                  temperature: 0.3,
                  max_tokens: 8192
                })
              });
              
              const data = await response.json();
              let solution;
              
              try {
                const content = data.choices[0].message.content;
                const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
                const jsonStr = jsonMatch ? jsonMatch[1] : content;
                solution = JSON.parse(jsonStr);
              } catch (e) {
                console.log(`‚ö†Ô∏è AI-Fehler bei Issue #${issue.number}:`, e.message);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: '‚ö†Ô∏è Konnte keine automatische L√∂sung generieren. Manuelle Pr√ºfung erforderlich.'
                });
                
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'in-progress'
                }).catch(() => {});
                
                continue;
              }
              
              console.log(`‚úÖ L√∂sung generiert: ${solution.solution_type} (${solution.complexity})`);
              
              // Erstelle Branch
              const branchName = `autonomous/issue-${issue.number}`;
              
              try {
                // Git Konfiguration
                execSync('git config user.name "Autonomous Bot"');
                execSync('git config user.email "autonomous@nexifyai.com"');
                
                // Erstelle und wechsle zu Branch
                execSync(`git checkout -b ${branchName}`);
                
                // Wende Datei√§nderungen an
                let filesCreated = 0;
                for (const file of solution.files || []) {
                  const filePath = file.path;
                  const dir = require('path').dirname(filePath);
                  
                  if (file.action === 'delete') {
                    if (fs.existsSync(filePath)) {
                      fs.unlinkSync(filePath);
                      execSync(`git rm ${filePath}`);
                      console.log(`üóëÔ∏è Gel√∂scht: ${filePath}`);
                    }
                  } else {
                    // Erstelle Verzeichnis wenn n√∂tig
                    if (!fs.existsSync(dir)) {
                      fs.mkdirSync(dir, { recursive: true });
                    }
                    
                    fs.writeFileSync(filePath, file.content);
                    execSync(`git add ${filePath}`);
                    console.log(`${file.action === 'create' ? '‚ú® Erstellt' : 'üìù Aktualisiert'}: ${filePath}`);
                    filesCreated++;
                  }
                }
                
                // Erstelle Tests
                for (const test of solution.tests || []) {
                  const dir = require('path').dirname(test.path);
                  if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir, { recursive: true });
                  }
                  fs.writeFileSync(test.path, test.content);
                  execSync(`git add ${test.path}`);
                  console.log(`üß™ Test erstellt: ${test.path}`);
                }
                
                if (filesCreated === 0) {
                  console.log('‚ö†Ô∏è Keine Dateien zum Committen');
                  execSync('git checkout main');
                  continue;
                }
                
                // Commit
                const commitMsg = solution.commit_message || `fix: L√∂sung f√ºr Issue #${issue.number}`;
                execSync(`git commit -m "${commitMsg.replace(/"/g, '\\"')}"`);
                
                // Push
                execSync(`git push -u origin ${branchName}`);
                
                console.log(`‚úÖ Branch ${branchName} erstellt und gepusht`);
                
                // Erstelle PR
                const { data: pr } = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: solution.pr_title || `ü§ñ Auto-Fix: ${issue.title}`,
                  body: `${solution.pr_body || 'Automatische L√∂sung generiert'}
                  
## ü§ñ Autonome L√∂sung

**Issue:** Closes #${issue.number}
**Typ:** ${solution.solution_type}
**Komplexit√§t:** ${solution.complexity}

### üìä Analyse
${solution.analysis || 'N/A'}

### üîß √Ñnderungen
${(solution.files || []).map(f => `- ${f.action}: \`${f.path}\``).join('\n')}

### üß™ Tests
${(solution.tests || []).length > 0 ? 'Tests wurden hinzugef√ºgt' : 'Keine zus√§tzlichen Tests n√∂tig'}

---
ü§ñ Automatisch erstellt durch Autonomous System`,
                  head: branchName,
                  base: 'main'
                });
                
                console.log(`‚úÖ PR #${pr.number} erstellt`);
                
                // F√ºge Labels hinzu
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: ['ü§ñ autonomous-bot', 'auto-merge', 'auto-deploy']
                });
                
                // Auto-Approve (da von Bot erstellt)
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  event: 'APPROVE',
                  body: '‚úÖ Auto-approved: Code wurde durch AI generiert und gepr√ºft'
                });
                
                // Kommentar am Original-Issue
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `‚úÖ **L√∂sung erstellt!**\n\nPull Request: #${pr.number}\n\nüöÄ Der PR wird automatisch gemerged sobald alle Checks erfolgreich sind.`
                });
                
                // Wechsle zur√ºck zu main
                execSync('git checkout main');
                
              } catch (error) {
                console.log(`‚ùå Fehler bei Issue #${issue.number}:`, error.message);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `‚ùå **Fehler bei automatischer L√∂sung**\n\n\`\`\`\n${error.message}\n\`\`\`\n\nWerde es erneut versuchen.`
                });
                
                // Cleanup
                try {
                  execSync('git checkout main');
                  execSync(`git branch -D ${branchName} || true`);
                } catch (e) {}
              }
            }

  # ============================================================
  # AUTONOMOUS PR PROCESSOR - Automatische PR-Verarbeitung
  # ============================================================
  auto-process-prs:
    name: üîÄ Auto-Process PRs
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'schedule'
    timeout-minutes: 15
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Setup
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install
        run: pnpm install --frozen-lockfile

      - name: Autonomous PR Processing
        uses: actions/github-script@v7
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            console.log('ü§ñ AUTONOMER MODUS: PR-Verarbeitung gestartet');
            
            // Hole alle offenen PRs
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 20
            });
            
            console.log(`üìã Gefunden: ${prs.length} offene PRs`);
            
            for (const pr of prs) {
              console.log(`\nüîç Verarbeite PR #${pr.number}: ${pr.title}`);
              
              // Hole PR Details
              const { data: prDetails } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              // Pr√ºfe ob mergeable
              if (!prDetails.mergeable) {
                console.log(`‚ö†Ô∏è PR #${pr.number} hat Merge-Konflikte`);
                
                // Versuche Auto-Rebase
                try {
                  await github.rest.pulls.updateBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number
                  });
                  console.log(`‚úÖ Branch aktualisiert`);
                } catch (e) {
                  console.log(`‚ö†Ô∏è Konnte Branch nicht aktualisieren:`, e.message);
                  continue;
                }
              }
              
              // Hole Checks
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const allChecksPassed = checks.check_runs.length === 0 || 
                checks.check_runs.every(check => 
                  check.conclusion === 'success' || 
                  check.conclusion === 'skipped' ||
                  check.conclusion === null
                );
              
              // Hole Reviews
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              const hasApproval = reviews.some(r => r.state === 'APPROVED');
              const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
              
              // Auto-Review wenn noch keine Review vorhanden
              if (reviews.length === 0 || !hasApproval) {
                console.log(`üîç F√ºhre automatisches Code-Review durch...`);
                
                // Hole Diff
                const { data: diff } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  mediaType: { format: 'diff' }
                });
                
                // AI Code Review
                const reviewPrompt = `Review diesen Pull Request:

Titel: ${pr.title}
Beschreibung: ${pr.body || 'Keine Beschreibung'}

Diff (gek√ºrzt):
${diff.substring(0, 8000)}

Bewerte den Code nach:
1. Funktionalit√§t & Korrektheit
2. Code-Qualit√§t & Best Practices
3. Security
4. Performance
5. Tests

Antworte im JSON-Format:
{
  "verdict": "APPROVE|REQUEST_CHANGES|COMMENT",
  "score": 0-100,
  "summary": "Zusammenfassung",
  "issues": ["kritisches Issue 1", "..."],
  "suggestions": ["Verbesserungsvorschlag 1", "..."]
}`;

                try {
                  const response = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`
                    },
                    body: JSON.stringify({
                      model: 'deepseek-chat',
                      messages: [
                        {
                          role: 'system',
                          content: 'Du bist ein erfahrener Code-Reviewer. Bewerte objektiv und konstruktiv.'
                        },
                        {
                          role: 'user',
                          content: reviewPrompt
                        }
                      ],
                      temperature: 0.2,
                      max_tokens: 2048
                    })
                  });
                  
                  const reviewData = await response.json();
                  const reviewContent = reviewData.choices[0].message.content;
                  const jsonMatch = reviewContent.match(/```(?:json)?\s*([\s\S]*?)```/);
                  const reviewResult = JSON.parse(jsonMatch ? jsonMatch[1] : reviewContent);
                  
                  console.log(`üìä Review Score: ${reviewResult.score}/100`);
                  console.log(`üìã Verdict: ${reviewResult.verdict}`);
                  
                  // Erstelle Review
                  const reviewBody = `## ü§ñ Autonomes Code-Review

**Score:** ${reviewResult.score}/100

### üìä Zusammenfassung
${reviewResult.summary}

${reviewResult.issues && reviewResult.issues.length > 0 ? `
### ‚ö†Ô∏è Kritische Punkte
${reviewResult.issues.map(i => `- ${i}`).join('\n')}
` : ''}

${reviewResult.suggestions && reviewResult.suggestions.length > 0 ? `
### üí° Verbesserungsvorschl√§ge
${reviewResult.suggestions.map(s => `- ${s}`).join('\n')}
` : ''}

---
ü§ñ Automatisches Review durch Autonomous System`;

                  let reviewEvent = 'COMMENT';
                  if (reviewResult.verdict === 'APPROVE' && reviewResult.score >= 70) {
                    reviewEvent = 'APPROVE';
                  } else if (reviewResult.verdict === 'REQUEST_CHANGES' || reviewResult.score < 50) {
                    reviewEvent = 'REQUEST_CHANGES';
                  }
                  
                  await github.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    event: reviewEvent,
                    body: reviewBody
                  });
                  
                  console.log(`‚úÖ Review erstellt: ${reviewEvent}`);
                  
                  if (reviewEvent === 'APPROVE') {
                    hasApproval = true;
                  }
                  
                } catch (e) {
                  console.log(`‚ö†Ô∏è Fehler beim Review:`, e.message);
                }
              }
              
              // Auto-Merge wenn alle Bedingungen erf√ºllt
              const labels = pr.labels.map(l => l.name);
              const isAutoMerge = labels.includes('auto-merge') || labels.includes('ü§ñ autonomous-bot');
              
              if (isAutoMerge && hasApproval && !hasChangesRequested && allChecksPassed && prDetails.mergeable) {
                console.log(`üöÄ Auto-Merge PR #${pr.number}...`);
                
                try {
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    merge_method: 'squash',
                    commit_title: `${pr.title} (#${pr.number})`,
                    commit_message: `${pr.body || ''}\n\nü§ñ Auto-merged by Autonomous System`
                  });
                  
                  console.log(`‚úÖ PR #${pr.number} gemerged!`);
                  
                  // L√∂sche Branch
                  try {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${pr.head.ref}`
                    });
                    console.log(`üóëÔ∏è Branch gel√∂scht`);
                  } catch (e) {}
                  
                  // Schlie√üe verkn√ºpfte Issues
                  const issueMatches = (pr.body || '').match(/#(\d+)/g);
                  if (issueMatches) {
                    for (const match of issueMatches) {
                      const issueNum = parseInt(match.substring(1));
                      try {
                        await github.rest.issues.update({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNum,
                          state: 'closed'
                        });
                        
                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNum,
                          body: `‚úÖ **Automatisch gel√∂st!**\n\nL√∂sung wurde in PR #${pr.number} gemerged.\n\nü§ñ Autonomous System`
                        });
                        
                        console.log(`‚úÖ Issue #${issueNum} geschlossen`);
                      } catch (e) {}
                    }
                  }
                  
                } catch (error) {
                  console.log(`‚ùå Merge-Fehler bei PR #${pr.number}:`, error.message);
                }
              } else {
                console.log(`‚è≥ PR #${pr.number} noch nicht merge-ready`);
                console.log(`  - Auto-Merge: ${isAutoMerge}`);
                console.log(`  - Approved: ${hasApproval}`);
                console.log(`  - Changes Requested: ${hasChangesRequested}`);
                console.log(`  - Checks Passed: ${allChecksPassed}`);
                console.log(`  - Mergeable: ${prDetails.mergeable}`);
              }
            }

  # ============================================================
  # AUTONOMOUS DEPLOYMENT - Automatisches Deployment
  # ============================================================
  auto-deploy:
    name: üöÄ Auto-Deploy
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    timeout-minutes: 10
    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Deploy to Vercel
        id: deploy
        run: |
          npm install -g vercel@latest
          
          echo "üöÄ Starte autonomes Deployment..."
          
          # Vercel Deployment
          vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}
          vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}
          URL=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }})
          
          echo "url=$URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployed to: $URL"

      - name: Deployment Notification
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const url = '${{ steps.deploy.outputs.url }}';
            
            // Erstelle Deployment-Issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üöÄ Auto-Deployment: ${new Date().toISOString()}`,
              body: `## Automatisches Production Deployment
              
              **URL:** ${url}
              **Commit:** ${context.sha}
              **Branch:** ${context.ref}
              **Trigger:** ${context.eventName}
              
              ### ‚úÖ Status
              - Deployment: Erfolgreich
              - Environment: Production
              - Methode: Autonomous System
              
              ---
              ü§ñ Automatisch deployed durch Autonomous System`,
              labels: ['deployment', 'ü§ñ autonomous-bot', 'production']
            });
            
            console.log('‚úÖ Deployment erfolgreich:', url);

      - name: Post-Deployment Health Check
        run: |
          echo "üè• F√ºhre Health-Check durch..."
          sleep 10
          
          URL="${{ steps.deploy.outputs.url }}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
          
          if [ "$STATUS" = "200" ]; then
            echo "‚úÖ Health-Check erfolgreich: $STATUS"
          else
            echo "‚ö†Ô∏è Health-Check failed: $STATUS"
            exit 1
          fi

  # ============================================================
  # CONTINUOUS MONITORING - √úberwachung & Selbstheilung
  # ============================================================
  monitor:
    name: üìä Monitor & Self-Heal
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    timeout-minutes: 5
    
    steps:
      - name: System Health Check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            console.log('üè• System Health Check...');
            
            // Sammle Metriken
            const [issues, prs, workflows] = await Promise.all([
              github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              }),
              github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 50
              }),
              github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 20
              })
            ]);
            
            const metrics = {
              issues: {
                open: issues.data.filter(i => !i.pull_request).length,
                stale: issues.data.filter(i => {
                  const daysSince = (Date.now() - new Date(i.updated_at)) / (1000 * 60 * 60 * 24);
                  return daysSince > 7;
                }).length
              },
              prs: {
                open: prs.data.length,
                stale: prs.data.filter(pr => {
                  const daysSince = (Date.now() - new Date(pr.updated_at)) / (1000 * 60 * 60 * 24);
                  return daysSince > 3;
                }).length
              },
              workflows: {
                failed: workflows.data.workflow_runs.filter(w => w.conclusion === 'failure').length,
                success: workflows.data.workflow_runs.filter(w => w.conclusion === 'success').length
              }
            };
            
            console.log('üìä Metriken:', JSON.stringify(metrics, null, 2));
            
            // Automatische Aktionen bei Problemen
            if (metrics.workflows.failed > 0) {
              console.log('‚ö†Ô∏è Fehlgeschlagene Workflows erkannt - Triggere Auto-Fix');
              // Trigger workflow-fix workflow
            }
            
            if (metrics.issues.stale > 5) {
              console.log('‚ö†Ô∏è Zu viele stale Issues - Triggere Auto-Cleanup');
              // Trigger issue cleanup
            }
            
            if (metrics.prs.stale > 3) {
              console.log('‚ö†Ô∏è Zu viele stale PRs - Triggere Auto-Review');
              // Trigger PR processing
            }
            
            // Status-Report
            const healthScore = Math.round(
              (1 - metrics.issues.open / 50) * 30 +
              (1 - metrics.prs.open / 20) * 30 +
              (metrics.workflows.success / Math.max(metrics.workflows.success + metrics.workflows.failed, 1)) * 40
            );
            
            console.log(`üè• Health Score: ${healthScore}/100`);
            
            if (healthScore < 50) {
              console.log('üö® KRITISCHER ZUSTAND - Aktiviere aggressive Autonomie');
              // Trigger emergency procedures
            }
