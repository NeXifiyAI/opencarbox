name: ðŸ”€ Auto-Merge AI PRs

on:
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["ðŸ¤– AI Development Team", "CI/CD Pipeline"]
    types: [completed]

env:
  GH_TOKEN: ${{ secrets.GH_TOKEN }}

jobs:
  auto-merge:
    name: ðŸš€ Auto-Merge
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'pull_request_review' && github.event.review.state == 'approved') ||
      (github.event_name == 'check_suite' && github.event.check_suite.conclusion == 'success') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for Auto-Merge Eligibility
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            // Get open PRs with ai-generated label
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 10
            });
            
            for (const pr of prs) {
              const labels = pr.labels.map(l => l.name);
              
              // Only auto-merge AI-generated PRs with auto-merge label
              if (!labels.includes('ai-generated') || !labels.includes('auto-merge')) {
                continue;
              }
              
              console.log(`Checking PR #${pr.number}: ${pr.title}`);
              
              // Check if all checks passed
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const allPassed = checks.check_runs.every(
                check => check.conclusion === 'success' || check.conclusion === 'skipped'
              );
              
              if (!allPassed) {
                console.log(`PR #${pr.number}: Not all checks passed`);
                continue;
              }
              
              // Check for approvals
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              const hasApproval = reviews.some(r => r.state === 'APPROVED');
              const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
              
              if (hasChangesRequested) {
                console.log(`PR #${pr.number}: Changes requested`);
                continue;
              }
              
              // Auto-approve if no human approval but checks pass
              if (!hasApproval && labels.includes('ai-generated')) {
                console.log(`PR #${pr.number}: Auto-approving AI-generated PR`);
                
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  event: 'APPROVE',
                  body: 'ðŸ¤– Auto-approved: All checks passed for AI-generated PR'
                });
              }
              
              // Merge the PR
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: `${pr.title} (#${pr.number})`,
                  commit_message: `Auto-merged AI-generated PR\n\n${pr.body || ''}`
                });
                
                console.log(`âœ… Merged PR #${pr.number}`);
                
                // Delete the branch
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${pr.head.ref}`
                  });
                  console.log(`ðŸ—‘ï¸ Deleted branch ${pr.head.ref}`);
                } catch (e) {
                  console.log(`Could not delete branch: ${e.message}`);
                }
                
              } catch (error) {
                console.log(`Failed to merge PR #${pr.number}: ${error.message}`);
              }
            }

  # ============================================================
  # Cleanup stale AI branches
  # ============================================================
  cleanup:
    name: ðŸ§¹ Cleanup Stale Branches
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    
    steps:
      - name: Cleanup Old AI Branches
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const { data: branches } = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            const aiBranches = branches.filter(b => b.name.startsWith('ai/'));
            const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            
            for (const branch of aiBranches) {
              try {
                const { data: commit } = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: branch.name
                });
                
                const commitDate = new Date(commit.commit.committer.date).getTime();
                
                if (commitDate < oneWeekAgo) {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branch.name}`
                  });
                  console.log(`ðŸ—‘ï¸ Deleted stale branch: ${branch.name}`);
                }
              } catch (e) {
                console.log(`Error processing branch ${branch.name}: ${e.message}`);
              }
            }
