name: ğŸ”§ Bot Maintenance & Lifecycle Management

# Automatische Wartung, Reaktivierung und Erhaltung aller Bots
# Stellt sicher, dass alle Bots funktionsfÃ¤hig bleiben

on:
  schedule:
    # Alle 6 Stunden - Bot-Health-Check
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Maintenance Action'
        required: true
        default: 'health-check'
        type: choice
        options:
          - health-check
          - reactivate-all
          - update-all
          - optimize-all
          - repair-broken
      force:
        description: 'Force execution even if healthy'
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  workflows: write

concurrency:
  group: bot-maintenance
  cancel-in-progress: false

env:
  GH_TOKEN: ${{ secrets.GH_TOKEN }}
  DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}

jobs:
  # ============================================================
  # Bot Inventory & Health Check
  # ============================================================
  inventory:
    name: ğŸ“‹ Bot Inventory
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      bots: ${{ steps.scan.outputs.bots }}
      health_status: ${{ steps.scan.outputs.health_status }}
      needs_action: ${{ steps.scan.outputs.needs_action }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Scan All Bots
        id: scan
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            console.log('ğŸ” Scanne alle Bot-Workflows...');
            
            // Definiere alle bekannten Bots
            const knownBots = [
              {
                name: 'master-orchestrator',
                file: 'master-orchestrator.yml',
                type: 'orchestrator',
                critical: true,
                schedule: 'daily',
                description: 'Zentrale Steuerung mit ADMIN-Rechten'
              },
              {
                name: 'auto-pilot',
                file: 'auto-pilot.yml',
                type: 'automation',
                critical: true,
                schedule: '30min',
                description: 'Autonome Projekt-VervollstÃ¤ndigung'
              },
              {
                name: 'full-autonomy',
                file: 'full-autonomy.yml',
                type: 'automation',
                critical: true,
                schedule: '15min',
                description: 'VollstÃ¤ndige Automatisierung'
              },
              {
                name: 'ci-performance',
                file: 'ci-performance.yml',
                type: 'ci-cd',
                critical: true,
                schedule: 'on-push',
                description: 'Performance-optimierte CI/CD'
              },
              {
                name: 'qa-bot',
                file: 'qa-bot.yml',
                type: 'quality',
                critical: true,
                schedule: 'on-push',
                description: 'Quality & Testing'
              },
              {
                name: 'security-bot',
                file: 'security-bot.yml',
                type: 'security',
                critical: true,
                schedule: 'on-push',
                description: 'Security Scans'
              },
              {
                name: 'devops-bot',
                file: 'devops-bot.yml',
                type: 'deployment',
                critical: true,
                schedule: 'on-push',
                description: 'Deployment & Optimization'
              },
              {
                name: 'ai-team',
                file: 'ai-team.yml',
                type: 'ai',
                critical: true,
                schedule: 'on-event',
                description: 'AI Development Team'
              },
              {
                name: 'ai-auto-merge',
                file: 'ai-auto-merge.yml',
                type: 'automation',
                critical: false,
                schedule: 'on-event',
                description: 'AI PR Auto-Merge'
              },
              {
                name: 'auto-merge',
                file: 'auto-merge.yml',
                type: 'automation',
                critical: false,
                schedule: 'on-event',
                description: 'Dependabot Auto-Merge'
              },
              {
                name: 'ai-self-healing',
                file: 'ai-self-healing.yml',
                type: 'maintenance',
                critical: false,
                schedule: 'on-failure',
                description: 'Self-Healing System'
              }
            ];
            
            const workflowDir = '.github/workflows';
            const botStatus = [];
            
            // PrÃ¼fe jeden Bot
            for (const bot of knownBots) {
              const filePath = path.join(workflowDir, bot.file);
              const exists = fs.existsSync(filePath);
              
              let status = {
                ...bot,
                exists,
                healthy: false,
                lastRun: null,
                lastStatus: 'unknown',
                needsUpdate: false,
                issues: []
              };
              
              if (!exists) {
                status.issues.push('Workflow-Datei fehlt');
                botStatus.push(status);
                continue;
              }
              
              // Lese Workflow-Datei
              const content = fs.readFileSync(filePath, 'utf8');
              
              // PrÃ¼fe auf veraltete Actions
              const deprecatedPatterns = [
                /actions\/checkout@v[1-3]/,
                /actions\/setup-node@v[1-3]/,
                /actions\/cache@v[1-3]/,
                /actions\/upload-artifact@v[1-3]/,
                /pnpm\/action-setup@v[1-3]/
              ];
              
              for (const pattern of deprecatedPatterns) {
                if (pattern.test(content)) {
                  status.needsUpdate = true;
                  status.issues.push(`Veraltete Action: ${pattern.source}`);
                }
              }
              
              // PrÃ¼fe auf fehlende Permissions
              if (content.includes('github-token:') && !content.includes('permissions:')) {
                status.issues.push('Fehlende Permissions-Definition');
              }
              
              // PrÃ¼fe auf fehlende Timeouts
              if (!content.includes('timeout-minutes:')) {
                status.issues.push('Fehlende Timeout-Konfiguration');
              }
              
              // Hole Workflow-Runs
              try {
                const { data: workflows } = await github.rest.actions.listRepoWorkflows({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                const workflow = workflows.workflows.find(w => w.path.includes(bot.file));
                
                if (workflow) {
                  const { data: runs } = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflow.id,
                    per_page: 5
                  });
                  
                  if (runs.workflow_runs.length > 0) {
                    const lastRun = runs.workflow_runs[0];
                    status.lastRun = lastRun.created_at;
                    status.lastStatus = lastRun.conclusion || lastRun.status;
                    
                    // Bot ist healthy wenn letzter Run erfolgreich oder in Bearbeitung
                    status.healthy = ['success', 'in_progress', 'queued'].includes(status.lastStatus);
                    
                    if (status.lastStatus === 'failure') {
                      status.issues.push('Letzter Run fehlgeschlagen');
                    }
                  } else {
                    status.issues.push('Noch nie ausgefÃ¼hrt');
                  }
                }
              } catch (e) {
                console.log(`âš ï¸ Konnte Runs fÃ¼r ${bot.name} nicht abrufen:`, e.message);
              }
              
              botStatus.push(status);
            }
            
            // Zusammenfassung
            const summary = {
              total: botStatus.length,
              healthy: botStatus.filter(b => b.healthy).length,
              unhealthy: botStatus.filter(b => !b.healthy).length,
              missing: botStatus.filter(b => !b.exists).length,
              needsUpdate: botStatus.filter(b => b.needsUpdate).length,
              critical: botStatus.filter(b => b.critical && !b.healthy).length
            };
            
            console.log('ğŸ“Š Bot-Status:', summary);
            
            // Ausgabe
            core.setOutput('bots', JSON.stringify(botStatus));
            core.setOutput('health_status', JSON.stringify(summary));
            core.setOutput('needs_action', summary.unhealthy > 0 || summary.needsUpdate > 0);
            
            // Erstelle Ãœbersichts-Tabelle
            let table = '| Bot | Status | Type | Last Run | Issues |\n';
            table += '|-----|--------|------|----------|--------|\n';
            
            for (const bot of botStatus) {
              const statusEmoji = bot.healthy ? 'âœ…' : bot.exists ? 'âš ï¸' : 'âŒ';
              const issues = bot.issues.length > 0 ? bot.issues.join(', ') : 'Keine';
              table += `| ${bot.name} | ${statusEmoji} | ${bot.type} | ${bot.lastRun || 'N/A'} | ${issues} |\n`;
            }
            
            console.log('\n' + table);
            
            return { botStatus, summary, table };

  # ============================================================
  # Bot Reactivation - Reaktiviert inaktive Bots
  # ============================================================
  reactivate:
    name: ğŸ”„ Reactivate Bots
    runs-on: ubuntu-latest
    needs: inventory
    if: needs.inventory.outputs.needs_action == 'true' || github.event.inputs.force == 'true'
    timeout-minutes: 15
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Reactivate Unhealthy Bots
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const bots = JSON.parse('${{ needs.inventory.outputs.bots }}');
            const healthStatus = JSON.parse('${{ needs.inventory.outputs.health_status }}');
            
            console.log('ğŸ”„ Reaktiviere unhealthy Bots...');
            console.log(`ğŸ“Š Status: ${healthStatus.unhealthy} unhealthy, ${healthStatus.needsUpdate} need update`);
            
            const reactivated = [];
            const failed = [];
            
            // Hole alle Workflows
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            for (const bot of bots) {
              if (!bot.exists) {
                console.log(`âš ï¸ ${bot.name}: Workflow-Datei fehlt - Ã¼berspringe`);
                continue;
              }
              
              if (!bot.healthy && bot.lastStatus === 'failure') {
                console.log(`ğŸ”„ Reaktiviere ${bot.name}...`);
                
                const workflow = workflows.workflows.find(w => w.path.includes(bot.file));
                
                if (workflow && workflow.state === 'active') {
                  try {
                    // Versuche Workflow neu zu triggern wenn mÃ¶glich
                    if (bot.schedule === 'on-event' || bot.type === 'orchestrator') {
                      // Kann nicht automatisch getriggert werden
                      console.log(`â„¹ï¸ ${bot.name}: Event-basiert, warte auf nÃ¤chsten Trigger`);
                    } else {
                      console.log(`âœ… ${bot.name}: Bereit fÃ¼r nÃ¤chsten Trigger`);
                    }
                    
                    reactivated.push(bot.name);
                  } catch (e) {
                    console.log(`âŒ Fehler bei ${bot.name}:`, e.message);
                    failed.push(bot.name);
                  }
                } else if (workflow && workflow.state === 'disabled') {
                  console.log(`âš ï¸ ${bot.name}: Workflow ist deaktiviert`);
                  // Workflows kÃ¶nnen nicht programmatisch aktiviert werden
                  failed.push(bot.name);
                }
              }
            }
            
            console.log(`\nâœ… Reaktiviert: ${reactivated.length}`);
            console.log(`âŒ Fehlgeschlagen: ${failed.length}`);
            
            core.setOutput('reactivated', JSON.stringify(reactivated));
            core.setOutput('failed', JSON.stringify(failed));

  # ============================================================
  # Bot Update - Aktualisiert veraltete Bots
  # ============================================================
  update:
    name: ğŸ”§ Update Bots
    runs-on: ubuntu-latest
    needs: inventory
    if: needs.inventory.outputs.needs_action == 'true' || github.event.inputs.action == 'update-all'
    timeout-minutes: 20
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Update Outdated Bots
        id: update
        run: |
          echo "ğŸ”§ Aktualisiere veraltete Workflows..."
          
          UPDATED_FILES=()
          
          for file in .github/workflows/*.yml; do
            if [ ! -f "$file" ]; then continue; fi
            
            MODIFIED=false
            
            # Backup
            cp "$file" "$file.bak"
            
            # Update Actions v1-3 â†’ v4
            if grep -q "actions/checkout@v[1-3]" "$file"; then
              sed -i 's/actions\/checkout@v[1-3]/actions\/checkout@v4/g' "$file"
              MODIFIED=true
              echo "  âœ… Updated checkout action in $(basename $file)"
            fi
            
            if grep -q "actions/setup-node@v[1-3]" "$file"; then
              sed -i 's/actions\/setup-node@v[1-3]/actions\/setup-node@v4/g' "$file"
              MODIFIED=true
              echo "  âœ… Updated setup-node action in $(basename $file)"
            fi
            
            if grep -q "actions/cache@v[1-3]" "$file"; then
              sed -i 's/actions\/cache@v[1-3]/actions\/cache@v4/g' "$file"
              MODIFIED=true
              echo "  âœ… Updated cache action in $(basename $file)"
            fi
            
            if grep -q "actions/upload-artifact@v[1-3]" "$file"; then
              sed -i 's/actions\/upload-artifact@v[1-3]/actions\/upload-artifact@v4/g' "$file"
              MODIFIED=true
              echo "  âœ… Updated upload-artifact action in $(basename $file)"
            fi
            
            if grep -q "pnpm/action-setup@v[1-3]" "$file"; then
              sed -i 's/pnpm\/action-setup@v[1-3]/pnpm\/action-setup@v4/g' "$file"
              MODIFIED=true
              echo "  âœ… Updated pnpm action in $(basename $file)"
            fi
            
            if [ "$MODIFIED" = true ]; then
              UPDATED_FILES+=("$file")
              echo "  ğŸ“ Modified: $(basename $file)"
            else
              # Restore if not modified
              mv "$file.bak" "$file"
            fi
          done
          
          # Cleanup backups
          rm -f .github/workflows/*.yml.bak
          
          if [ ${#UPDATED_FILES[@]} -gt 0 ]; then
            echo "has_updates=true" >> $GITHUB_OUTPUT
            echo "updated_count=${#UPDATED_FILES[@]}" >> $GITHUB_OUTPUT
          else
            echo "has_updates=false" >> $GITHUB_OUTPUT
            echo "updated_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Commit Updates
        if: steps.update.outputs.has_updates == 'true'
        run: |
          git config user.name "Bot Maintenance System"
          git config user.email "maintenance@nexifyai.com"
          
          git add .github/workflows/*.yml
          git commit -m "ğŸ”§ Auto-Update: Workflow-Modernisierung

          - Actions v1-3 â†’ v4 aktualisiert
          - ${{ steps.update.outputs.updated_count }} Workflows modernisiert
          
          ğŸ¤– Automatisch durch Bot Maintenance System"
          
          git push

      - name: Create Update Report
        if: steps.update.outputs.has_updates == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ğŸ”§ Bot Maintenance: Workflows aktualisiert',
              body: `## Automatische Bot-Aktualisierung
              
              Das Bot Maintenance System hat veraltete Workflows aktualisiert.
              
              ### âœ… DurchgefÃ¼hrte Updates
              - Actions auf neueste Versionen aktualisiert (v4)
              - Anzahl aktualisierter Workflows: ${{ steps.update.outputs.updated_count }}
              
              ### ğŸ“Š Status
              - Alle Bots sind jetzt auf dem neuesten Stand
              - KompatibilitÃ¤t mit GitHub Actions sichergestellt
              
              ---
              ğŸ¤– Automatisch durch Bot Maintenance System`,
              labels: ['bot-maintenance', 'automated', 'enhancement']
            });

  # ============================================================
  # Bot Optimization - Optimiert Bot-Performance
  # ============================================================
  optimize:
    name: âš¡ Optimize Bots
    runs-on: ubuntu-latest
    needs: inventory
    if: github.event.inputs.action == 'optimize-all'
    timeout-minutes: 15
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Analyze & Optimize
        uses: actions/github-script@v7
        env:
          BOTS: ${{ needs.inventory.outputs.bots }}
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const bots = JSON.parse(process.env.BOTS);
            
            console.log('âš¡ Analysiere Bot-Performance...');
            
            const optimizations = [];
            
            for (const bot of bots) {
              if (!bot.exists) continue;
              
              const suggestions = [];
              
              // Schedule-Optimierung
              if (bot.schedule === '15min' && bot.lastStatus === 'success') {
                suggestions.push('Schedule auf 30 Min erhÃ¶hen (stabil)');
              }
              
              // Timeout-Optimierung basierend auf durchschnittlicher Laufzeit
              if (!bot.issues.includes('timeout')) {
                suggestions.push('Timeout-Konfiguration ist optimal');
              }
              
              // Caching-Empfehlungen
              if (bot.type === 'ci-cd' || bot.type === 'quality') {
                suggestions.push('Dependency-Caching bereits implementiert');
              }
              
              if (suggestions.length > 0) {
                optimizations.push({
                  bot: bot.name,
                  suggestions
                });
              }
            }
            
            // Erstelle Optimierungs-Report
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'âš¡ Bot Optimization Report',
              body: `## Performance-Analyse
              
              ${optimizations.map(opt => `
              ### ${opt.bot}
              ${opt.suggestions.map(s => `- ${s}`).join('\n')}
              `).join('\n')}
              
              ---
              ğŸ¤– Generiert durch Bot Maintenance System`,
              labels: ['bot-maintenance', 'performance', 'automated']
            });

  # ============================================================
  # Health Report - Erstellt Gesundheitsbericht
  # ============================================================
  report:
    name: ğŸ“Š Health Report
    runs-on: ubuntu-latest
    needs: [inventory, reactivate, update]
    if: always()
    timeout-minutes: 5
    
    steps:
      - name: Generate Health Report
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const bots = JSON.parse('${{ needs.inventory.outputs.bots }}');
            const healthStatus = JSON.parse('${{ needs.inventory.outputs.health_status }}');
            
            const healthScore = Math.round(
              (healthStatus.healthy / healthStatus.total) * 100
            );
            
            const statusEmoji = healthScore >= 90 ? 'ğŸŸ¢' : 
                               healthScore >= 70 ? 'ğŸŸ¡' : 'ğŸ”´';
            
            const report = `## ğŸ¤– Bot Maintenance Report
            
            **Zeitstempel:** ${new Date().toISOString()}
            **Health Score:** ${healthScore}/100 ${statusEmoji}
            
            ### ğŸ“Š Ãœbersicht
            - **Total Bots:** ${healthStatus.total}
            - **Healthy:** ${healthStatus.healthy} âœ…
            - **Unhealthy:** ${healthStatus.unhealthy} âš ï¸
            - **Missing:** ${healthStatus.missing} âŒ
            - **Need Update:** ${healthStatus.needsUpdate} ğŸ”§
            - **Critical Issues:** ${healthStatus.critical} ğŸš¨
            
            ### ğŸ¤– Bot-Status
            
            ${bots.map(bot => `
            #### ${bot.name} ${bot.healthy ? 'âœ…' : 'âš ï¸'}
            - **Type:** ${bot.type}
            - **Schedule:** ${bot.schedule}
            - **Critical:** ${bot.critical ? 'Ja' : 'Nein'}
            - **Last Run:** ${bot.lastRun || 'Nie'}
            - **Status:** ${bot.lastStatus}
            ${bot.issues.length > 0 ? `- **Issues:** ${bot.issues.join(', ')}` : ''}
            `).join('\n')}
            
            ### ğŸ”§ DurchgefÃ¼hrte Aktionen
            - Reactivation: ${{ needs.reactivate.result || 'skipped' }}
            - Update: ${{ needs.update.result || 'skipped' }}
            
            ### ğŸ’¡ Empfehlungen
            ${healthScore < 90 ? `
            - âš ï¸ Einige Bots benÃ¶tigen Aufmerksamkeit
            - FÃ¼hre \`optimize-all\` aus fÃ¼r Performance-Verbesserungen
            ` : `
            - âœ… Alle Systeme optimal
            - Kontinuierliche Ãœberwachung aktiv
            `}
            
            ---
            ğŸ¤– *NÃ¤chster Check in 6 Stunden*`;
            
            // Update Dashboard
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'bot-maintenance-dashboard',
              state: 'open',
              per_page: 1
            });
            
            if (issues.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'ğŸ¤– Bot Maintenance Dashboard',
                body: report,
                labels: ['bot-maintenance-dashboard', 'pinned']
              });
            } else {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues[0].number,
                body: report
              });
            }
            
            console.log('ğŸ“Š Health Report erstellt');
            console.log(`Health Score: ${healthScore}/100`);
